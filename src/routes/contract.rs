use crate::provider::{contract_runtime_code, provider_from_chain, provider_url_from_chain};
use axum::{
    extract::Query,
    http,
    response::{IntoResponse, Response},
    Json,
};
use ethers::types::{Address, Bytes, Chain};
use heimdall::decompile::DecompileBuilder;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use tempfile::TempDir;

/// Data that the caller provides to lookup a contract.
#[derive(Deserialize, Debug)]
pub struct ContractQuery {
    /// Chain the contract is deployed on.
    chain_id: u64,
    /// Address of the contract.
    address: String, // TODO change this to `Address`.
}

/// Data returned for a verified contract.
#[derive(Serialize)]
pub struct VerifiedResponse {
    // TODO This should probably use the same `SuccessfulVerification` struct from `verify.rs`.
}

/// Data returned for an unverified contract that was decompiled.
#[derive(Serialize)]
pub struct DecompiledResponse {
    /// Chain the contract is deployed on.
    pub chain_id: Chain,
    /// Address of the contract.
    pub address: Address,
    /// True if the contract is verified, false otherwise.
    pub verified: bool,
    /// Inferred ABI of the contract.
    pub abi: String, // TODO return this as a `LosslessAbi`.
    /// The deployed code of the contract, also known as the runtime code. This is the code that
    /// was returned by executing the creation code and lives at the contract address on-chain.
    pub bytecode: String, // TODO return this as `CompactDeployedBytecode`.
    /// The disassembled bytecode of the contract.
    pub disassembled: String,
    /// Inferred Solidity source code of the contract from decompiling the bytecode.
    pub solidity: String,
}

/// Error response for when a contract is not found.
#[derive(Serialize)]
pub struct ErrorResponse {
    /// Error message.
    pub error: String,
}

/// Response for the contract route.
enum ApiResponse {
    /// Contract is verified so verification data is returned. This is currently unused since Cove
    /// does not persist verification data. This is why the leading underscore is used.
    _Verified(VerifiedResponse),
    /// Contract is not verified so decompilation data is returned.
    Decompiled(DecompiledResponse),
    /// An error occurred while processing the request.
    Error(ErrorResponse),
}

impl IntoResponse for ApiResponse {
    fn into_response(self) -> Response {
        match self {
            ApiResponse::_Verified(success) => {
                (http::StatusCode::OK, Json(success)).into_response()
            }
            ApiResponse::Decompiled(success) => {
                (http::StatusCode::OK, Json(success)).into_response()
            }
            ApiResponse::Error(error) => {
                (http::StatusCode::BAD_REQUEST, Json(error)).into_response()
            }
        }
    }
}

/// This route is intended to return data for a contract that was previously verified, and for
/// unverified contracts falls back to decompiling the bytecode with heimdall. However, Cove does
/// not currently persist verification results in a database. As a result, this route will always
/// decompile the bytecode with heimdall.
pub async fn contract(Query(contract_query): Query<ContractQuery>) -> impl IntoResponse {
    let chain_id = Chain::try_from(contract_query.chain_id).unwrap();
    let address = Address::from_str(&contract_query.address).unwrap();

    // TODO Check if the contract is verified.

    // Otherwise, decompile and return what we can.
    let provider = provider_from_chain(chain_id);
    let runtime_code = contract_runtime_code(&provider, address).await;
    println!("runtime_code: {:?}", runtime_code);

    if runtime_code == Bytes::from_str("0x").unwrap() {
        return ApiResponse::Error(ErrorResponse {
            error: format!("No runtime code for contract address {address} on chain ID {chain_id}"),
        })
    }

    let temp_dir = TempDir::new().unwrap();
    DecompileBuilder::new(&runtime_code.to_string())
        // Comment out the below line to have files saved locally, which can be useful for
        // debugging.
        .output(temp_dir.path().to_str().unwrap())
        .include_sol(true)
        .verbosity(0)
        .skip_resolving(false)
        .rpc(&provider_url_from_chain(chain_id))
        .decompile();

    // Read in the files generated by heimdall, their names are always the same:
    //   - abi.json
    //   - bytecode.evm
    //   - decompiled.sol
    //   - disassembled.asm
    let abi = std::fs::read_to_string(temp_dir.path().join("abi.json")).unwrap();
    let bytecode = std::fs::read_to_string(temp_dir.path().join("bytecode.evm")).unwrap();
    let solidity = std::fs::read_to_string(temp_dir.path().join("decompiled.sol")).unwrap();
    let disassembled = std::fs::read_to_string(temp_dir.path().join("disassembled.asm")).unwrap();

    // Respond.
    let response = DecompiledResponse {
        chain_id,
        address,
        verified: true,
        abi,
        bytecode,
        disassembled,
        solidity,
    };
    ApiResponse::Decompiled(response)
}
