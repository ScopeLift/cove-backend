/// Module for abstracting framework-specific logic.
use crate::bytecode::{
    ExpectedCreationBytecode, ExpectedDeployedBytecode, FoundCreationBytecode,
    FoundDeployedBytecode, ImmutableReferences,
};
use ethers::types::Bytes;
use ethers_solc::artifacts::{LosslessAbi, SettingsMetadata};
use std::{
    error::Error,
    path::{Path, PathBuf},
    process::Command,
    result::Result,
};

/// Trait for abstracting framework-specific logic, such as how to build the project and parse
/// compilation artifacts.
pub trait Framework {
    // -------- Config and Setup --------

    /// Return an instance of the framework if the path is a supported project.
    fn new(path: &Path) -> Result<Self, Box<dyn Error + Send + Sync>>
    where
        Self: Sized;

    /// Verifies this is the expected project type and returns true if so.
    fn is_supported(path: &Path) -> bool;

    /// Returns the build commands to compile the repo.
    fn build_commands(&self, hint: Option<String>) -> Result<Vec<Command>, Box<dyn Error>>;

    /// Returns the artifacts generated by compilation.
    fn get_artifacts(&self) -> Result<Vec<PathBuf>, Box<dyn Error>>;

    // -------- Bytecode Structuring --------

    /// Uses data from the artifact to structure the creation code of that artifact. The code in the
    /// artifact is known as the "found" code, as it's what we found in the artifact. This is in
    /// contrast to the "expected" code which is what is on-chain.
    fn structure_found_creation_code(
        &self,
        artifact: &Path,
    ) -> Result<FoundCreationBytecode, Box<dyn Error>>;

    /// Uses data from the found creation code to structure the expected creation code.
    fn structure_expected_creation_code(
        &self,
        artifact: &Path,
        found: &FoundCreationBytecode,
        expected: &Bytes,
    ) -> Result<ExpectedCreationBytecode, Box<dyn Error>>;

    /// Uses data from the artifact to structure the deployed code of that artifact. The code in the
    /// artifact is known as the "found" code, as it's what we found in the artifact. This is in
    /// contrast to the "expected" code which is what is on-chain.
    fn structure_found_deployed_code(
        &self,
        artifact: &Path,
    ) -> Result<FoundDeployedBytecode, Box<dyn Error>>;

    /// Uses data from the found deployed code to structure the expected deployed code.
    fn structure_expected_deployed_code(
        &self,
        found: &FoundDeployedBytecode,
        expected: &Bytes,
    ) -> Result<ExpectedDeployedBytecode, Box<dyn Error>>;

    // -------- Artifact parsing --------

    /// Returns the ABI of the given artifact.
    fn get_artifact_abi(artifact: &Path) -> Result<LosslessAbi, Box<dyn Error>>;

    /// Returns the creation code of the given artifact.
    fn get_artifact_creation_code(artifact: &Path) -> Result<Bytes, Box<dyn Error>>;

    /// Returns the deployed code of the given artifact.
    fn get_artifact_deployed_code(
        artifact: &Path,
    ) -> Result<(Bytes, ImmutableReferences), Box<dyn Error>>;

    /// Returns the metadata settings of the given artifact.
    fn get_artifact_metadata_settings(artifact: &Path) -> Result<SettingsMetadata, Box<dyn Error>>;
}
